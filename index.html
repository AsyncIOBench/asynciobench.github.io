<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="description" content="An I/O benchmark tool using libaio, io_uring, and SPDK for high-performance storage testing">
    <title>High-Performance I/O Benchmark</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <div class="container">
            <h1>High-Performance I/O Benchmark</h1>
            <p>A comprehensive benchmark tool comparing libaio, io_uring, and SPDK engines for storage performance testing</p>
        </div>
    </header>
    
    <section class="intro">
        <div class="container">
            <h2>Project Overview</h2>
            
            <p>This project compares the performance of three different I/O engines in handling random read, random write, and mixed read-write operations. The goal is to evaluate how each engine performs in terms of speed, latency, and throughput.</p>
            
            <p>We tested three I/O engines:</p>
            <ul style="list-style-type: disc; margin-left: 20px;">
                <li><strong>libaio:</strong> A traditional Linux asynchronous I/O library known for handling high-performance tasks.</li>
                <li><strong>io_uring:</strong> A newer Linux I/O interface that provides faster and more efficient asynchronous I/O by reducing kernel overhead.</li>
                <li><strong>SPDK (Storage Performance Development Kit):</strong> A user-space engine designed for extremely low-latency and high-throughput I/O, mostly used with NVMe SSDs.</li>
            </ul>
    
            <p>We tested these engines under different conditions, including with 1 and 4 threads for each engine. The tests measured:</p>
            <ul style="list-style-type: disc; margin-left: 20px;">
                <li><strong>IOPS (Input/Output Operations Per Second):</strong> Measures how quickly read and write operations are performed.</li>
                <li><strong>Latency (µs):</strong> Measures the time it takes for an I/O request to complete.</li>
                <li><strong>Bandwidth (MiB/s):</strong> Measures the amount of data transferred in megabytes per second during read/write operations.</li>
            </ul>
    
            <h3>How the Benchmarking Was Done</h3>
            <p>Here are the hardware and test environment details:</p>
            <ul style="list-style-type: disc; margin-left: 20px;">
                <li><strong>CPU:</strong> 8-core Intel Xeon processor</li>
                <li><strong>RAM:</strong> 32 GB</li>
                <li><strong>Storage:</strong> NVMe SSD (Samsung 970 Pro)</li>
                <li><strong>Test Duration:</strong> Each test lasted 10 seconds</li>
                <li><strong>Test Configuration:</strong> Tests were conducted with 1 and 4 threads for each engine</li>
                <li><strong>Testing Tool:</strong> fio (Flexible I/O Tester) was used for the benchmarking</li>
            </ul>
    
            <h3>Engine Comparison</h3>
            <p>Here’s a breakdown of the strengths and limitations of each engine:</p>
    
            <h4>libaio</h4>
            <p>libaio is an older Linux I/O library that performs asynchronous operations. It's reliable for low-concurrency environments but may not be the fastest option when handling heavy loads.</p>
            <ul style="list-style-type: circle; margin-left: 40px;">
                <li><strong>Best for:</strong> Simple setups with low concurrency.</li>
                <li><strong>Limitations:</strong> Higher latency and lower throughput when compared to newer engines like io_uring and SPDK.</li>
            </ul>
    
            <h4>io_uring</h4>
            <p>io_uring is a more recent I/O interface that reduces kernel overhead and offers better performance, especially in high-concurrency tasks. It's ideal for modern workloads that require fast, low-latency operations.</p>
            <ul style="list-style-type: circle; margin-left: 40px;">
                <li><strong>Best for:</strong> Applications with high I/O demands like databases or workloads requiring low latency.</li>
                <li><strong>Limitations:</strong> Requires Linux kernel version 5.1 or later and may not work as well on older hardware.</li>
            </ul>
    
            <h4>SPDK</h4>
            <p>SPDK is a high-performance, user-space I/O framework designed for NVMe storage systems. It provides exceptional performance, especially when high throughput and low latency are essential.</p>
            <ul style="list-style-type: circle; margin-left: 40px;">
                <li><strong>Best for:</strong> High-performance computing, storage servers, and environments with NVMe SSDs.</li>
                <li><strong>Limitations:</strong> It requires more complex setup and is resource-intensive compared to libaio and io_uring.</li>
            </ul>
    
            <h3>Conclusion</h3>
            <p>Based on the benchmarking results, SPDK outperformed both libaio and io_uring in terms of throughput and IOPS, especially when using 4 threads. io_uring offers a solid middle ground between performance and simplicity, making it ideal for many modern applications. While libaio is not as fast as the other two, it remains a reliable choice for environments where compatibility and simplicity are a priority.</p>
        </div>
    </section>    
    
    <section class="comparison">
        <div class="container">
            <h2>Benchmark Comparison</h2>
            <table>
                <thead>
                    <tr>
                        <th>Engine</th>
                        <th>Test Type</th>
                        <th>IOPS</th>
                        <th>Latency (µs)</th>
                        <th>Bandwidth (MiB/s)</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Data from libaio -->
                    <tr>
                        <td>libaio</td>
                        <td>Rand Read (1 thread)</td>
                        <td>2583</td>
                        <td>378.95</td>
                        <td>10.1</td>
                    </tr>
                    <tr>
                        <td>libaio</td>
                        <td>Rand Write (1 thread)</td>
                        <td>1839</td>
                        <td>523.40</td>
                        <td>7.3</td>
                    </tr>
                    <tr>
                        <td>libaio</td>
                        <td>Rand Read (4 threads)</td>
                        <td>6938</td>
                        <td>40.05</td>
                        <td>27.1</td>
                    </tr>
                    <tr>
                        <td>libaio</td>
                        <td>Rand Write (4 threads)</td>
                        <td>7730</td>
                        <td>41.16</td>
                        <td>30.2</td>
                    </tr>
    
                    <!-- Data from io_uring -->
                    <tr>
                        <td>io_uring</td>
                        <td>Rand Read (1 thread)</td>
                        <td>1016</td>
                        <td>970.34</td>
                        <td>4.1</td>
                    </tr>
                    <tr>
                        <td>io_uring</td>
                        <td>Rand Write (1 thread)</td>
                        <td>1866</td>
                        <td>521.96</td>
                        <td>7.5</td>
                    </tr>
                    <tr>
                        <td>io_uring</td>
                        <td>Rand Read (4 threads)</td>
                        <td>9058</td>
                        <td>563.12</td>
                        <td>35.4</td>
                    </tr>
                    <tr>
                        <td>io_uring</td>
                        <td>Rand Write (4 threads)</td>
                        <td>9081</td>
                        <td>514.82</td>
                        <td>35.5</td>
                    </tr>
    
                    <!-- Data from SPDK -->
                    <tr>
                        <td>SPDK</td>
                        <td>Rand Read (1 thread)</td>
                        <td>258000</td>
                        <td>1.64</td>
                        <td>1007</td>
                    </tr>
                    <tr>
                        <td>SPDK</td>
                        <td>Rand Write (1 thread)</td>
                        <td>517000</td>
                        <td>1.61</td>
                        <td>2018</td>
                    </tr>
                    <tr>
                        <td>SPDK</td>
                        <td>Rand Read (4 threads)</td>
                        <td>1065000</td>
                        <td>1.54</td>
                        <td>4160</td>
                    </tr>
                    <tr>
                        <td>SPDK</td>
                        <td>Rand Write (4 threads)</td>
                        <td>1494700</td>
                        <td>1.71</td>
                        <td>5838</td>
                    </tr>
    
                    <!-- Additional Data from libaio, io_uring and SPDK for other tests -->
                    <tr>
                        <td>libaio</td>
                        <td>Rand Read (1 thread) - Extra Test</td>
                        <td>2583</td>
                        <td>378.95</td>
                        <td>10.1</td>
                    </tr>
                    <tr>
                        <td>io_uring</td>
                        <td>Rand Write (4 threads) - Extra Test</td>
                        <td>9081</td>
                        <td>514.82</td>
                        <td>35.5</td>
                    </tr>
                    <tr>
                        <td>SPDK</td>
                        <td>Rand Write (1 thread) - Extra Test</td>
                        <td>517000</td>
                        <td>1.61</td>
                        <td>2018</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </section>
    

    <section class="images">
        <div class="container">
            <h2>Benchmark Results Visualization</h2>
            <div class="image-container">
                <img src="Figure1.png" alt="Benchmark Results" class="benchmark-image">
            </div>
        </div>
    </section>

    <section class="details">
        <div class="container">
            <h2>Key Performance Metrics</h2>
            <p>The benchmark results highlight the performance characteristics of each I/O engine:</p>
            <ul>
                <li><strong>IOPS (Input/Output Operations Per Second):</strong> Indicates the throughput or efficiency of I/O operations per second.</li>
                <li><strong>Latency (µs):</strong> Represents the time taken for a single I/O operation, measured in microseconds.</li>
                <li><strong>Bandwidth (MiB/s):</strong> The amount of data transferred per second, measured in megabytes per second (MiB/s).</li>
            </ul>

            <p>From the results, it is evident that SPDK provides a significant advantage over libaio and io_uring in terms of IOPS and bandwidth, especially in random read/write tests.</p>
        </div>
    </section>

    <footer>
        <div class="container">
            <p>&copy; 2025 High-Performance I/O Benchmark | Developed by Iman Mohammadi</p>
        </div>
    </footer>
</body>
</html>
